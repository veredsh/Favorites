Index: wc.c
===================================================================
--- wc.c	(revision 4)
+++ wc.c	(working copy)
@@ -35,7 +35,7 @@
 int
 main(int argc, char *argv[])
 {
-  int fd, i;
+  int fd, i; 
 
   if(argc <= 1){
     wc(0, "");
@@ -43,10 +43,8 @@
   }
 
   for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
-    }
+		if((fd = link_handler(argv[i], 0)) < 0)
+		  exit();
     wc(fd, argv[i]);
     close(fd);
   }
Index: user.h
===================================================================
--- user.h	(revision 4)
+++ user.h	(working copy)
@@ -23,6 +23,15 @@
 int sleep(int);
 int uptime(void);
 
+// link
+int symlink(const char *oldpath, const char *newpath);
+int readlink (const char *pathname, char *buf, uint bufsiz);
+
+// tag
+int ftag(int fd, char * key, char * val);
+int funtag(int fd, char * key);
+int gettag(int fd, char * key, char * buf);
+
 // ulib.c
 int stat(char*, struct stat*);
 char* strcpy(char*, char*);
@@ -36,3 +45,4 @@
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+int link_handler(char* path, int omode);
Index: Makefile
===================================================================
--- Makefile	(revision 4)
+++ Makefile	(working copy)
@@ -151,6 +151,7 @@
 UPROGS=\
 	_cat\
 	_echo\
+	_find\
 	_forktest\
 	_grep\
 	_init\
@@ -164,6 +165,9 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_s1\
+	_slt\
+	_tag\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -233,6 +237,7 @@
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	s1.c slt.c tag.c find.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
Index: mkfs.c
===================================================================
--- mkfs.c	(revision 4)
+++ mkfs.c	(working copy)
@@ -10,11 +10,15 @@
 #include "fs.h"
 #include "stat.h"
 #include "param.h"
+#include "file.h"
 
-int nblocks = 985;
+# define MAXBUFFSIZE 512
+
+int nblocks = 65456;
 int nlog = LOGSIZE;
+//int ninodes = 258084;
 int ninodes = 200;
-int size = 1024;
+int size = 65536;
 
 int fsfd;
 struct superblock sb;
@@ -63,11 +67,14 @@
   struct dirent de;
   char buf[512];
   struct dinode din;
-
+  
   if(argc < 2){
     fprintf(stderr, "Usage: mkfs fs.img files...\n");
     exit(1);
   }
+  
+  //printf("\n\n%d\n\n",sizeof(struct inode));
+  //printf("\n\n%s\n\n",argv[1]);
 
   assert((512 % sizeof(struct dinode)) == 0);
   assert((512 % sizeof(struct dirent)) == 0);
@@ -89,6 +96,10 @@
 
   printf("used %d (bit %d ninode %zu) free %u log %u total %d\n", usedblocks,
          bitblocks, ninodes/IPB + 1, freeblock, nlog, nblocks+usedblocks+nlog);
+  
+  
+  //printf("\n\n%d\n\n",size - (usedblocks + nlog));
+  //printf("\n\n%d\n\n",size - (nblocks + usedblocks + nlog));
 
   assert(nblocks + usedblocks + nlog == size);
 
@@ -148,7 +159,6 @@
   winode(rootino, &din);
 
   balloc(usedblocks);
-
   exit(0);
 }
 
@@ -228,12 +238,13 @@
 void
 balloc(int used)
 {
-  uchar buf[512];
+  
+  uchar buf[MAXBUFFSIZE];
   int i;
 
   printf("balloc: first %d blocks have been allocated\n", used);
-  assert(used < 512*8);
-  bzero(buf, 512);
+  assert(used < MAXBUFFSIZE * 8);
+  bzero(buf, MAXBUFFSIZE);
   for(i = 0; i < used; i++){
     buf[i/8] = buf[i/8] | (0x1 << (i%8));
   }
Index: slt.c
===================================================================
--- slt.c	(revision 0)
+++ slt.c	(revision 0)
@@ -0,0 +1,157 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+#define BUFSIZ 512
+#define ITOA_BASE 10
+// int test1(){
+//   printf(1, "mkdir dir\n");
+// 	if(mkdir("dir") < 0){
+// 			printf(1, "mkdir failed\n");
+// 			exit();
+// 	}
+// 	
+// 	printf(1, "mkdir dir/dir2\n");
+// 	if(mkdir("dir/dir2") < 0){
+// 			printf(1, "mkdir failed\n");
+// 			exit();
+// 	}
+// 	
+// 	printf(1, "open a file\n");
+// 	fd = open("/dir/dir2/a", O_CREATE | O_RDWR);
+// 	
+// 	printf(1, "write to a file\n");
+// 	if((bytes = write(fd, message, strlen(message))) < 0){
+// 	  printf(1, "write failed\n");
+// 		exit();
+// 	}
+// 	printf(1, "wrote %d bytes\n", bytes);
+// 	
+// 	
+// 	printf(1, "symbolic link dir/b to a\n");
+// 	if(symlink("/dir/dir2/a", "/dir/b") < 0){
+// 	  printf(1, "symbolic link failed\n");
+// 		exit();
+// 	}
+// 	
+// 	printf(1, "symbolic link c to b\n");
+// 	if(symlink("/dir/b", "/c") < 0){
+// 	  printf(1, "symbolic link failed\n");
+// 		exit();
+// 	}		
+// }
+
+// int test2(){
+// 				printf(1, "open a0 file\n");
+// 	fd = open("0", O_CREATE | O_RDWR);
+// 	
+// 	printf(1, "write to 0 file\n");
+// 	if((bytes = write(fd, message, strlen(message))) < 0){
+// 	  printf(1, "write failed\n");
+// 		exit();
+// 	}
+// 	for(i = 1; i < 5; i++){
+// // 		memmove(tmpbuf, but, BUFSIZ);
+// // 		memmove(pbuf, "/dir", 3);
+// // 		pbuf += 3;
+// // 		itoa(i, num);
+// // 		memmove(pbuf, num, strlen(num));
+// // 		pbuf+=strlen(num);
+// 	 
+//     //printf(1, "i: %d\n", i);
+//     itoa(i, num);
+// 		if(mkdir(num) < 0){
+// 			printf(1, "mkdir failed\n");
+// 			exit();
+// 	  }
+// 	  if(chdir(num) < 0){
+// 			printf(1, "chdir failed\n");
+// 			exit();
+// 		}
+// 		itoa(i-1, num2);
+// 		*pbuf = '/'; pbuf++;
+// 		
+// 		memmove(pbuf,num2, strlen(num2));
+// 	  if(symlink(buf, num) < 0){
+// 	    printf(1, "symbolic link failed\n");
+// 		  exit();
+// 	  }	
+// 	  memmove(pbuf, num, strlen(num));
+// 		pbuf+=strlen(num);
+// 	}
+//   
+// 	readlink("4", buf, BUFSIZ);
+// 	// get symlink c's target path
+// 	printf(1, "readpath(\"4\") = %s\n", buf);
+// 	if(close(fd) < 0){
+// 	  printf(1, "close failed\n");
+// 		exit();
+// 	}
+// }
+
+// int test3(){
+// 					mkdir("dir");
+// 	fd = open("dir/test", O_CREATE | O_RDWR);
+// 	if(symlink("dir", "dir2") < 0){
+// 	    printf(1, "symbolic link failed\n");
+// 		  exit();
+// 	}
+// 	readlink("dir2", buf, BUFSIZ);
+// 	printf(1, "target : %s\n", buf);
+// }
+
+char*
+itoa(int xx, char* buff)
+{
+  static char digits[] = "0123456789ABCDEF";
+  char tmp_buf[16];
+  int i, neg, j;
+  uint x;
+
+  neg = 0;
+  if(xx < 0){
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+  do{
+    tmp_buf[i++] = digits[x % ITOA_BASE];
+  }while((x /= ITOA_BASE) != 0);
+  if(neg)
+    tmp_buf[i++] = '-';
+  
+  j = 0;
+  while(--i >= 0)
+    buff[j++] = tmp_buf[i];
+  buff[j] = '\0';
+  return buff;
+}
+
+
+
+
+int main(){
+	//int fd, i;
+	//int bytes;
+	//char *message = "what the fuck\n", num[10],  num2[10];
+	//char buf[BUFSIZ];//, *pbuf = buf;
+// 	memset(buf, '\0', BUFSIZ);
+// 	memset(num, '\0', 10);
+	//int fd;
+	if(symlink("README", "README2") < 0){
+	    printf(1, "symbolic link failed\n");
+		  exit();
+	}
+	if(symlink("x", "x2") < 0){
+	    printf(1, "symbolic link failed\n");
+		  exit();
+	}
+	if(symlink("x2", "x3") < 0){
+	    printf(1, "symbolic link failed\n");
+		  exit();
+	}
+
+	exit();			
+}
\ No newline at end of file
Index: fs.c
===================================================================
--- fs.c	(revision 4)
+++ fs.c	(working copy)
@@ -167,7 +167,7 @@
   initlock(&icache.lock, "icache");
 }
 
-static struct inode* iget(uint dev, uint inum);
+struct inode* iget(uint dev, uint inum);
 
 //PAGEBREAK!
 // Allocate a new inode with the given type on device dev.
@@ -212,6 +212,7 @@
   dip->nlink = ip->nlink;
   dip->size = ip->size;
   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+  dip->tag = ip->tag;
   log_write(bp);
   brelse(bp);
 }
@@ -219,7 +220,7 @@
 // Find the inode with number inum on device dev
 // and return the in-memory copy. Does not lock
 // the inode and does not read it from disk.
-static struct inode*
+struct inode*
 iget(uint dev, uint inum)
 {
   struct inode *ip, *empty;
@@ -289,6 +290,7 @@
     ip->nlink = dip->nlink;
     ip->size = dip->size;
     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+    ip->tag = dip->tag;
     brelse(bp);
     ip->flags |= I_VALID;
     if(ip->type == 0)
@@ -356,9 +358,10 @@
 static uint
 bmap(struct inode *ip, uint bn)
 {
-  uint addr, *a;
+  uint addr, addr2, *a;
   struct buf *bp;
 
+  // Direct
   if(bn < NDIRECT){
     if((addr = ip->addrs[bn]) == 0)
       ip->addrs[bn] = addr = balloc(ip->dev);
@@ -366,6 +369,7 @@
   }
   bn -= NDIRECT;
 
+  // Indirect level 1
   if(bn < NINDIRECT){
     // Load indirect block, allocating if necessary.
     if((addr = ip->addrs[NDIRECT]) == 0)
@@ -379,6 +383,27 @@
     brelse(bp);
     return addr;
   }
+  bn -= NINDIRECT;
+  
+  // Indirect level 2
+  if(bn < MAXFILE){
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT + 1]) == 0)
+      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
+    
+    // Load indirect (level 2) block, allocating if necessary.
+    if((addr2 = ((uint*)addr)[bn % NINDIRECT]) == 0)
+      ((uint*)addr)[bn % NINDIRECT] = addr2 = balloc(ip->dev);
+    
+    bp = bread(ip->dev, addr2);
+    a = (uint*)bp->data;
+    if((addr2 = a[bn]) == 0){
+      a[bn] = addr2 = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    return addr2;
+  }
 
   panic("bmap: out of range");
 }
@@ -392,9 +417,16 @@
 itrunc(struct inode *ip)
 {
   int i, j;
-  struct buf *bp;
-  uint *a;
+  struct buf *bp, *bp2;
+  uint *a, *a2;
+  
+  // Tag
+  if(ip->tag){
+    bfree(ip->dev, ip->tag);
+    ip->tag = 0;
+  }
 
+  // Direct
   for(i = 0; i < NDIRECT; i++){
     if(ip->addrs[i]){
       bfree(ip->dev, ip->addrs[i]);
@@ -402,6 +434,7 @@
     }
   }
   
+  // Indirect level 1
   if(ip->addrs[NDIRECT]){
     bp = bread(ip->dev, ip->addrs[NDIRECT]);
     a = (uint*)bp->data;
@@ -413,6 +446,28 @@
     bfree(ip->dev, ip->addrs[NDIRECT]);
     ip->addrs[NDIRECT] = 0;
   }
+    
+  // Indirect level 2
+  if(ip->addrs[NDIRECT + 1]){
+    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
+    a = (uint*)bp->data;
+    for(i = 0; i < NINDIRECT; i++){
+      if(((uint*) ip->addrs[NDIRECT + 1])[i]){
+	bp2 = bread(ip->dev, ((uint*) ip->addrs[NDIRECT + 1])[i]);
+	a2 = (uint*)bp2->data;
+	for(j = 0; j < NINDIRECT; j++){
+	  if(a2[j])
+	    bfree(ip->dev, a2[j]);
+	}
+	brelse(bp2);
+	bfree(ip->dev, ((uint*) ip->addrs[NDIRECT + 1])[i]);
+	((uint*) ip->addrs[NDIRECT + 1])[i] = 0;
+      }
+    }
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
 
   ip->size = 0;
   iupdate(ip);
@@ -422,11 +477,12 @@
 void
 stati(struct inode *ip, struct stat *st)
 {
-  st->dev = ip->dev;
-  st->ino = ip->inum;
-  st->type = ip->type;
-  st->nlink = ip->nlink;
-  st->size = ip->size;
+  st->dev	= ip->dev;
+  st->ino	= ip->inum;
+  st->type	= ip->type;
+  st->nlink	= ip->nlink;
+  st->size	= ip->size;
+  st->tag	= ip->tag;
 }
 
 //PAGEBREAK!
@@ -448,7 +504,7 @@
   if(off + n > ip->size)
     n = ip->size - off;
 
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+  for(tot = 0; tot < n; tot += m, off += m, dst += m){
     bp = bread(ip->dev, bmap(ip, off/BSIZE));
     m = min(n - tot, BSIZE - off%BSIZE);
     memmove(dst, bp->data + off%BSIZE, m);
@@ -573,7 +629,7 @@
 //   skipelem("a", name) = "", setting name = "a"
 //   skipelem("", name) = skipelem("////", name) = 0
 //
-static char*
+char*
 skipelem(char *path, char *name)
 {
   char *s;
@@ -648,3 +704,122 @@
 {
   return namex(path, 1, name);
 }
+
+// ************ //
+// File Tagging
+// ************ //
+
+int
+tag_place(struct inode * ip, struct buf *bp, char * key)
+{
+  int i;
+  
+  for(i = 0; i < ip->tagnum; i++){
+    if(strncmp((char *)bp->data + ((i * 2) * TAGSIZE), key, TAGSIZE) == 0)
+      return i;
+  }
+  
+  if(ip->tagnum < 16){
+    ip->tagnum++;
+    return (ip->tagnum - 1);
+  }
+  
+  return -1;
+}
+void
+tag_write(struct inode * ip, char * key, char * val)
+{
+  int place;
+  struct buf *bp;
+  int c;
+  
+  bp = bread(ip->dev, ip->tag);
+  place = tag_place(ip, bp, key);
+  if(place < 0){
+    cprintf("Error! A file can not have more that 16 tags!\n");
+    cprintf("File wasn't tagged!\n");
+  } else{
+    for(c = 0; c < TAGSIZE; c++){
+      memset(bp->data + (c + (place * 2 * TAGSIZE)), *(key + c), 1);
+      memset(bp->data + ((c + (place * 2 * TAGSIZE)) + TAGSIZE), *(val + c), 1);
+    }
+    //cprintf("bp->data: %s\n", bp->data + (place * 2 * TAGSIZE));
+    //cprintf("bp->data: %s\n", bp->data + (place * 2 * TAGSIZE) + TAGSIZE);
+  }
+  
+  log_write(bp);
+  brelse(bp);
+  iupdate(ip);
+}
+
+void
+tag_alloc(struct inode * ip)
+{
+  begin_trans();
+  ilock(ip);
+  if(ip->tag == 0){
+    ip->tag = balloc(ip->dev);
+    ip->tagnum = 0;
+  }
+  iunlock(ip);
+  commit_trans();
+}
+
+int
+ftag(int fd, char * key, char * val)
+{
+  struct inode * ip;
+  ip = proc->ofile[fd]->ip;
+  
+  tag_alloc(ip);
+  
+  begin_trans();
+  ilock(ip);
+  tag_write(ip, key, val);
+  iunlock(ip);
+  commit_trans();
+  
+  return 0;
+}
+
+int
+funtag(int fd, char * key)
+{
+  struct inode * ip;
+  ip = iget((uint)fd, 1);
+  return ip->tag;
+}
+
+int
+gettag(int fd, char * key, char * buf)
+{
+  char temp[512];
+  struct inode * ip;
+  struct buf *bp;
+  int i, tagnum;
+  
+  ip = proc->ofile[fd]->ip;
+  ilock(ip);
+  begin_trans();
+  bp = bread(ip->dev, ip->tag);
+  //cprintf("ip->tag: %d\n", ip->tag);
+  tagnum = ip->tagnum;
+  memmove(temp, bp->data, BSIZE);
+  brelse(bp);
+  iupdate(ip);
+  commit_trans();
+  
+  iunlock(ip);
+  
+  //cprintf("tagnum: %d\n",tagnum);
+  for(i = 0; i < tagnum; i++){
+    //cprintf("key: %s\n", temp + ((i * 2) * TAGSIZE));
+    //cprintf("val: %s\n", temp + (((i * 2) + 1) * TAGSIZE));
+    if(strncmp(temp + ((i * 2) * TAGSIZE), key, TAGSIZE) == 0){
+      strncpy(buf, temp + ((i * 2 + 1) * TAGSIZE), TAGSIZE);
+      return 0;
+    }
+  }
+  
+  return -1;
+}
\ No newline at end of file
Index: tag.c
===================================================================
--- tag.c	(revision 0)
+++ tag.c	(revision 0)
@@ -0,0 +1,173 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+#include "stat.h"
+#include "fs.h"
+
+#define TAG 1
+#define UNTAG 2
+#define GETTAG 3
+
+void print_help();
+int find_and_tag(char * path);
+void error(char * messege);
+void errori(char * messege, int d);
+
+char file_name[512];
+char file_tag[TAGSIZE];
+char file_tag_val[TAGSIZE];
+int operation;
+
+int
+main(int argc, char *argv[])
+{  
+  // Check args
+  if(argc < 2){
+    operation = GETTAG;
+    error("type tag -help for help");
+  } else {
+    if(*argv[1] != '-'){
+      error("type tag -help for help");
+    } else if(strcmp(argv[1],"-help") == 0){
+      print_help();
+    } else if((strcmp(argv[1],"-ftag")) == 0 && (argc == 5)){
+      operation = TAG;
+      strcpy(file_name,argv[2]);
+      strcpy(file_tag,argv[3]);
+      strcpy(file_tag_val,argv[4]);
+    } else if((strcmp(argv[1],"-funtag")) == 0 && (argc == 4)){
+      operation = UNTAG;
+      strcpy(file_name,argv[2]);
+      strcpy(file_tag,argv[3]);
+    } else if((strcmp(argv[1],"-gettag")) == 0 && (argc == 4)){
+      operation = GETTAG;
+      strcpy(file_name,argv[2]);
+      strcpy(file_tag,argv[3]);
+    } else {
+      error("type tag -help for help");
+    }
+  }
+  
+  if(find_and_tag(".") < 0)
+    error("could not find and tag");
+  
+  exit();
+}
+
+void
+print_help()
+{
+  printf(1, "  -ftag <file name> <tag name> <tag value>\n");
+  printf(1, "     Tags all files named <file name> with {<tag name>=<tag value>}\n");
+  printf(1, "  -funtag <file name> <tag name>\n");
+  printf(1, "     Untags all files named <file name> from the <tag name>\n");
+  printf(1, "  -gettag <file name> <tag name>\n");
+  printf(1, "     Get the tag value of <tag name> for all files named <file name>\n\n");
+  printf(1, "   * <file name> and <file tag> should be up to 30 characters!\n\n");
+  exit();
+}
+
+char*
+fmtname(char *path)
+{
+  static char buf[DIRSIZ+1];
+  char *p;
+  
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+  
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+    return p;
+  memmove(buf, p, strlen(p));
+  memset(buf+strlen(p), '\0', DIRSIZ-strlen(p));
+  return buf;
+}
+
+int
+make_tag(char * path, int fd)
+{
+  if(strcmp(fmtname(path),file_name) == 0){
+    if(operation == TAG){
+      if(ftag(fd, file_tag, file_tag_val) < 0)
+	return -1;
+      printf(1, "Tagged file: %s Tag < %s = %s >\n", path, file_tag, file_tag_val);
+    } else if(operation == UNTAG){
+      int ans = funtag(fd, file_tag);
+      if(ans < 0)
+	return -1;
+      if(ans)
+	printf(1, "Untagged file: %s\n", path);
+    } else if(operation == GETTAG){
+      int nn;
+      if((nn = gettag(fd, file_tag, file_tag_val)) < 0){
+	return -1;
+      }
+      printf(1, "File: %s Tag < %s = %s >\n", path, file_tag, file_tag_val);
+    }
+  }
+  return 0;
+}
+
+int
+find_and_tag(char * path){
+  char buf[512], *p;
+  int fd, ino;
+  struct stat st;
+  struct dirent de;
+
+  fd = open(path, O_RDONLY);
+    
+  ino = fstat(fd, &st);
+  if(ino < 0)
+    error("fstat");
+
+  switch(st.type){
+  case T_FILE:
+    make_tag(path, fd);
+    break;
+  
+  case T_DIR:
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+      printf(1, "ls: path too long\n");
+      break;
+    }
+    strcpy(buf, path);
+    p = buf+strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+      if(de.inum == 0)
+        continue;
+      memmove(p, de.name, DIRSIZ);
+      p[DIRSIZ] = 0;
+      if(stat(buf, &st) < 0){
+        printf(1, "tag: cannot stat %s\n", buf);
+        continue;
+      }
+      
+      // Recursive call
+      if(buf[strlen(buf) - 1] != '.'){
+	find_and_tag(buf);
+      }
+    }
+    break;
+  }
+  close(fd);
+  return 0;
+}
+
+void
+error(char * messege)
+{
+  printf(2, "Error: %s\n", messege);
+  exit();
+}
+
+void
+errori(char * messege, int d)
+{
+  printf(2, "Error: %s %d\n", messege, d);
+  exit();
+}
\ No newline at end of file
Index: fs.h
===================================================================
--- fs.h	(revision 4)
+++ fs.h	(working copy)
@@ -21,16 +21,23 @@
 
 #define NDIRECT 12
 #define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
+#define DNINDIRECT NINDIRECT * NINDIRECT
+#define MAXFILE (NDIRECT + (NINDIRECT * (1 + NINDIRECT)))
 
+#define TAGSIZE 32
+#define MAXTAGS 16
+
 // On-disk inode structure
 struct dinode {
-  short type;           // File type
-  short major;          // Major device number (T_DEV only)
-  short minor;          // Minor device number (T_DEV only)
-  short nlink;          // Number of links to inode in file system
-  uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
+  short type;		// File type
+  short major;		// Major device number (T_DEV only)
+  short minor;		// Minor device number (T_DEV only)
+  short nlink;		// Number of links to inode in file system
+  uint size;		// Size of file (bytes)
+  uint addrs[NDIRECT+2];// Data block addresses
+  uint tag;		// Tag
+  uint tagnum;		// Number of tags
+  uint padding[13];	// padding
 };
 
 // Inodes per block.
@@ -53,3 +60,6 @@
   char name[DIRSIZ];
 };
 
+int ftag(int fd, char * key, char * val);
+int funtag(int fd, char * key);
+int gettag(int fd, char * key, char * buf);
\ No newline at end of file
Index: exec.c
===================================================================
--- exec.c	(revision 4)
+++ exec.c	(working copy)
@@ -6,11 +6,15 @@
 #include "defs.h"
 #include "x86.h"
 #include "elf.h"
+#include "stat.h"
+#include "fs.h"
+#include "file.h"
+#define PATHSIZ 512
 
 int
 exec(char *path, char **argv)
 {
-  char *s, *last;
+  char *s, *last, target[PATHSIZ];
   int i, off;
   uint argc, sz, sp, ustack[3+MAXARG+1];
   struct elfhdr elf;
@@ -22,6 +26,16 @@
     return -1;
   ilock(ip);
   pgdir = 0;
+	
+	if(ip->type == T_LINK){
+	  iunlockput(ip);
+		readlink(path, target, PATHSIZ);
+		if((ip = namei(target)) == 0){
+		  cprintf("exec: broken link!\n");
+			exit();
+		}
+    ilock(ip);				
+	}
 
   // Check ELF header
   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
Index: grep.c
===================================================================
--- grep.c	(revision 4)
+++ grep.c	(working copy)
@@ -39,7 +39,7 @@
 {
   int fd, i;
   char *pattern;
-  
+
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
     exit();
@@ -52,10 +52,8 @@
   }
 
   for(i = 2; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
-    }
+    if((fd = link_handler(argv[i], 0)) < 0)
+		  exit();
     grep(pattern, fd);
     close(fd);
   }
Index: syscall.c
===================================================================
--- syscall.c	(revision 4)
+++ syscall.c	(working copy)
@@ -98,6 +98,11 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_symlink(void);
+extern int sys_readlink(void);
+extern int sys_ftag(void);
+extern int sys_funtag(void);
+extern int sys_gettag(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +126,11 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_symlink] sys_symlink,
+[SYS_readlink] sys_readlink,
+[SYS_ftag]    sys_ftag,
+[SYS_funtag]  sys_funtag,
+[SYS_gettag]  sys_gettag,
 };
 
 void
Index: syscall.h
===================================================================
--- syscall.h	(revision 4)
+++ syscall.h	(working copy)
@@ -21,3 +21,10 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+
+#define SYS_symlink   22
+#define SYS_readlink 23
+
+#define SYS_ftag   24
+#define SYS_funtag 25
+#define SYS_gettag 26
\ No newline at end of file
Index: stat.h
===================================================================
--- stat.h	(revision 4)
+++ stat.h	(working copy)
@@ -1,6 +1,7 @@
 #define T_DIR  1   // Directory
 #define T_FILE 2   // File
 #define T_DEV  3   // Special device
+#define T_LINK 4   // Link
 
 struct stat {
   short type;  // Type of file
@@ -8,4 +9,5 @@
   uint ino;    // Inode number on device
   short nlink; // Number of links to file
   uint size;   // Size of file in bytes
+  uint tag;     // Tag
 };
Index: usys.S
===================================================================
--- usys.S	(revision 4)
+++ usys.S	(working copy)
@@ -29,3 +29,8 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(symlink)
+SYSCALL(readlink)
+SYSCALL(ftag)
+SYSCALL(funtag)
+SYSCALL(gettag)
Index: s1.c
===================================================================
--- s1.c	(revision 0)
+++ s1.c	(revision 0)
@@ -0,0 +1,58 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+
+#define KB 1024
+#define MB KB * KB
+
+void error();
+
+int
+main(int argc, char *argv[])
+{
+  int fd;
+  char * buff;
+  
+  if(argc < 2) {
+    printf(2, "Error: number of args\n");
+    exit();
+  }
+  
+  // Creating the file
+  printf(1, "Creating a file..\n");
+  fd = open(argv[1],O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(2, "Error: opening a file\n");
+    exit();
+  }
+  // Init the buffs
+  buff = malloc(MB);
+  memset(buff, 'x', MB);
+  printf(1, "After msmset\n");
+  
+
+  // Writing 6KB
+    if(write(fd, buff, 6 * KB) < 6 * KB)
+      error(fd);
+  printf(1, "Finished writing 6KB (direct)\n");
+    /*
+  // Writing 70KB
+    if(write(fd, buff, 70 * KB) < 70 * KB)
+      error(fd);
+  printf(1, "Finished writing 70KB (single indirect)\n");
+      
+  // Writing 1MB
+    if(write(fd, buff, MB) < MB)
+      error(fd);
+  printf(1, "Finished writing 1MB (double indirect)\n");
+  */
+  close(fd);
+  exit();
+}
+
+void
+error(int fd){
+  printf(2, "Error: write to file\n");
+  close(fd);
+  exit();
+}
\ No newline at end of file
Index: sysproc.c
===================================================================
--- sysproc.c	(revision 4)
+++ sysproc.c	(working copy)
@@ -5,6 +5,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "fs.h"
 
 int
 sys_fork(void)
@@ -87,4 +88,4 @@
   xticks = ticks;
   release(&tickslock);
   return xticks;
-}
+}
\ No newline at end of file
Index: mkdir.c
===================================================================
--- mkdir.c	(revision 4)
+++ mkdir.c	(working copy)
@@ -7,10 +7,35 @@
 {
   int i;
 
+  /*
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
     exit();
   }
+  */
+  
+  if(argc == 1){
+    if(mkdir("x") < 0){
+      printf(2, "mkdir: %s failed to create\n", "x");
+      exit();
+    }
+    
+    if(mkdir("x/a") < 0){
+      printf(2, "mkdir: %s failed to create\n", "x/a");
+      exit();
+    }
+    
+    if(mkdir("x/b") < 0){
+      printf(2, "mkdir: %s failed to create\n", "x/b");
+      exit();
+    }
+    
+    if(mkdir("x/a/c") < 0){
+      printf(2, "mkdir: %s failed to create\n", "x/a/c");
+      exit();
+    }
+  }
+  
 
   for(i = 1; i < argc; i++){
     if(mkdir(argv[i]) < 0){
Index: cat.c
===================================================================
--- cat.c	(revision 4)
+++ cat.c	(working copy)
@@ -2,14 +2,16 @@
 #include "stat.h"
 #include "user.h"
 
-char buf[512];
+#define BUFSIZ 512 
 
+char buf[BUFSIZ];
+
 void
 cat(int fd)
 {
   int n;
-
-  while((n = read(fd, buf, sizeof(buf))) > 0)
+	
+  while((n = read(fd, buf, BUFSIZ)) > 0)
     write(1, buf, n);
   if(n < 0){
     printf(1, "cat: read error\n");
@@ -21,17 +23,15 @@
 main(int argc, char *argv[])
 {
   int fd, i;
-
+	
   if(argc <= 1){
     cat(0);
     exit();
   }
 
   for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
-    }
+    if((fd = link_handler(argv[i], 0)) < 0)
+		  exit();
     cat(fd);
     close(fd);
   }
Index: ls.c
===================================================================
--- ls.c	(revision 4)
+++ ls.c	(working copy)
@@ -45,7 +45,6 @@
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
-  
   case T_DIR:
     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
       printf(1, "ls: path too long\n");
Index: sysfile.c
===================================================================
--- sysfile.c	(revision 4)
+++ sysfile.c	(working copy)
@@ -13,7 +13,11 @@
 #include "fs.h"
 #include "file.h"
 #include "fcntl.h"
+#define MAX_PATH_SIZE 512
+#define MAX_LINK_LOOP 16
 
+#define min(a, b) ((a) < (b) ? (a) : (b))
+
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
 static int
@@ -272,7 +276,7 @@
     panic("create: dirlink");
 
   iunlockput(dp);
-
+  
   return ip;
 }
 
@@ -423,3 +427,205 @@
   fd[1] = fd1;
   return 0;
 }
+
+// Links
+
+int 
+sys_symlink(void)
+{
+  int oldpath = 0;
+	int newpath = 0;
+	
+	if((argint(0, &oldpath) < 0) || (argint(1, &newpath) < 0))
+	  return -1;
+	return symlink((const char*)oldpath, (const char*)newpath); 
+}
+
+int 
+sys_readlink(void)
+{
+  int pathname = 0;
+	int buf = 0;
+	int bufsiz = 0;
+	
+	if((argint(0, &pathname) < 0) || (argint(1, &buf) < 0) || (argint(2, &bufsiz) < 0))
+	  return -1;
+	return readlink((const char*)pathname, (char*)buf, (uint)bufsiz);
+}
+
+int create_link(char *path, int omode){
+  int fd;
+  struct file *f;
+  struct inode *ip;
+	
+	// create inode
+	begin_trans();
+  ip = create(path, T_LINK, 0, 0);
+  commit_trans();
+  if(ip == 0){
+		cprintf("create_link: create failed\n");
+    return -1;
+	}
+	if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+		cprintf("create_link: filealloc failed\n");
+    return -1;
+  }
+  iunlock(ip);
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+}
+
+int symlink(const char *oldpath, const char *newpath){
+  struct file *newfile;
+	int fd, target_len, dest_len;
+	char target_path[MAX_PATH_SIZE];	 // target path
+	char new_path[MAX_PATH_SIZE];
+	
+	// copy pathes because of const
+  target_len = strlen(oldpath);
+	memset(target_path, 0, MAX_PATH_SIZE);
+	memmove(target_path, oldpath, target_len);
+	target_path[target_len] = '\0';
+	//cprintf("oldpath's copy: %s\n", target_path);
+	
+	dest_len = strlen(newpath);
+	memset(new_path, 0, MAX_PATH_SIZE);
+	memmove(new_path, newpath, dest_len);
+	new_path[dest_len] = '\0';
+	
+	// create a new file and assign it a new inode
+	if((fd = create_link(new_path, O_CREATE | O_RDWR)) < 0){
+	  cprintf("error: create new link file");
+		return -1;
+	}
+	
+	// write target path to new file
+	newfile = proc->ofile[fd];
+  if(filewrite(newfile, target_path, target_len) < 0){
+	  cprintf("error: write target path to file");
+		return -1;
+	}
+  return 0;
+}
+
+int readlinkiter(char *pathname, char *buf, uint bufmaxsiz, uint bufsiz, struct inode *ip, int loopsz){
+  char name[DIRSIZ];
+	char target[MAX_PATH_SIZE];
+	struct inode *next;
+	int nbytes;// newbufsiz;
+	
+	if(((pathname = skipelem(pathname, name)) == 0) || (bufsiz == bufmaxsiz)){ 	
+	  return bufsiz;
+	}
+	ilock(ip);
+  if(ip->type != T_DIR){
+    panic("broken link\n");
+  }
+  if((next = dirlookup(ip, name, 0)) == 0)
+    panic("broken link\n");
+  iunlockput(ip); // done with father
+	ip = next;
+	ilock(ip);
+  if(ip->type != T_LINK){
+		iunlock(ip);
+	  nbytes = min(strlen(name), bufmaxsiz-bufsiz);
+		memmove(buf + bufsiz, name, nbytes);
+		if(bufsiz+nbytes < bufmaxsiz){
+		  buf[bufsiz+nbytes] = '/';
+		  nbytes++;
+		}
+	} else {
+		iunlock(ip);
+		if(loopsz == MAX_LINK_LOOP)
+		  panic("readlink: loop");
+	  nbytes = readi(ip, target, 0, MAX_PATH_SIZE);
+		target[nbytes] = '\0';
+		//cprintf("target: %s\n", target);
+		if(*target == '/'){ // absolute path
+      next = iget(ROOTDEV, ROOTINO);
+			bufsiz = 0; // start of path
+		}
+    else
+      next = idup(proc->cwd);
+		nbytes = readlinkiter(target, buf, bufmaxsiz, bufsiz, next, loopsz + 1);
+	}
+	return readlinkiter(pathname, buf, bufmaxsiz - nbytes, bufsiz + nbytes, ip, 0);
+}
+
+int readlink (const char *pathname, char *buf, uint bufsiz)
+{
+  char pathcpy[MAX_PATH_SIZE];
+	int length = strlen(pathname);
+	int sz;
+	struct inode *ip;
+	if(*pathname == '/') // absolute path
+      ip = iget(ROOTDEV, ROOTINO);
+    else
+      ip = idup(proc->cwd);
+	memset(buf, 0, bufsiz);
+	memset(pathcpy, 0, MAX_PATH_SIZE);
+	memmove(pathcpy, pathname, strlen(pathname)); // because of const
+  pathcpy[length] = '\0';
+  
+	sz = readlinkiter(pathcpy, buf, bufsiz-1, 0, ip, 0);
+	if(sz > 0)	
+	  buf[sz] = '\0';
+	return sz;
+}
+
+// Tagging
+int
+sys_ftag(void)
+{
+  int fd;
+  char * key;
+  char * val;
+  
+  if(argint(0, &fd) < 0)
+    return -1;
+  if(argstr(1, &key) < 0)
+    return -1;
+  if(argstr(2, &val) < 0)
+    return -1;
+  
+  return ftag(fd, key, val);
+}
+
+int
+sys_funtag(void)
+{
+  int fd;
+  char * key;
+  
+  if(argint(0, &fd) < 0)
+    return -1;
+  if(argstr(1, &key) < 0)
+    return -1;
+  
+  return funtag(fd, key);
+}
+
+int
+sys_gettag(void)
+{
+  int fd;
+  char * key;
+  char * buf;
+  
+  if(argint(0, &fd) < 0)
+    return -1;
+  if(argstr(1, &key) < 0)
+    return -1;
+  if(argstr(2, &buf) < 0)
+    return -1;
+  
+  return gettag(fd, key, buf);
+}
Index: find.c
===================================================================
--- find.c	(revision 0)
+++ find.c	(revision 0)
@@ -0,0 +1,247 @@
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+#include "stat.h"
+#include "fs.h"
+
+void error(char * messege);
+void errori(char * messege, int d);
+void find(char * path, int depth);
+char * fmtname(char *path);
+void print_file(char * buf, int fd, struct stat st, int depth);
+void print_help();
+
+int follow = 0;
+int search_by_name = 0;
+char name[128];
+int search_by_size = 0;
+int size;
+int search_by_type = 0;
+int search_by_tag = 0;
+char tag_key[32];
+char tag_val[32];
+char tag_buf[32];
+
+char link_buf[512];
+
+
+int
+main(int argc, char *argv[])
+{
+  // Variables
+  int i;
+  char path[512];
+  char * tag;
+  
+  // Set flags
+  if(argc > 1){
+    for(i = 1; i < argc; i++){
+      if(*argv[i] != '-'){
+	strcpy(path,argv[1]);
+      } else if(strcmp(argv[i],"-follow") == 0){
+	follow++;
+      } else if(strcmp(argv[i],"-help") == 0){
+	print_help();
+      } else if(strcmp(argv[i],"-name") == 0){
+	search_by_name++;
+	i++;
+	strcpy(name,argv[i]);
+      } else if(strcmp(argv[i],"-size") == 0){
+	search_by_size++;
+	i++;
+	if(*argv[i] == '+'){
+	  search_by_size++;
+	  size = atoi(argv[i] + 1);
+	} else if(*argv[i] == '-'){
+	  search_by_size++;
+	  search_by_size++;
+	  size = atoi(argv[i] + 1);
+	} else {
+	  size = atoi(argv[i]);
+	}
+      } else if(strcmp(argv[i],"-type") == 0){
+	i++;
+	if(strcmp(argv[i], "d") == 0){
+	  search_by_type = T_DIR;
+	} else if(strcmp(argv[i], "f") == 0){
+	  search_by_type = T_FILE;
+	} else if(strcmp(argv[i], "s") == 0){
+	  search_by_type = T_LINK;
+	} else {
+	 error("unknown file type"); 
+	}
+      } else if(strcmp(argv[i],"-tag") == 0){
+	search_by_tag++;
+	i++;
+	tag = strchr(argv[i], '=');
+	memmove(tag_key,argv[i], tag - argv[i]);
+	strcpy(tag_val,tag + 1);
+      } else {
+	error("unrecognized flag");
+      }
+    }
+  }
+  
+  // The actual search
+  find(path, 0);
+  
+  exit();
+}
+
+void
+find(char * path, int depth){
+  char buf[512];
+  char * p;
+  int fd, ino, link_len, fd_link, ino_link;
+  struct stat st, st_link;
+  struct dirent de;
+  
+  fd = open(path, O_RDONLY);
+  ino = fstat(fd, &st);
+  if(ino < 0)
+    return;
+
+  switch(st.type){
+  case T_FILE:
+    //printf(1, "file: %s\n", path);
+    print_file(path, fd, st, depth);
+    break;
+    
+  case T_LINK:
+    link_len = readlink(path, link_buf, 512);
+    if(link_len < 0)
+      error("read link");
+    link_buf[link_len - 1] = '\0';
+    fd_link = open(link_buf, O_RDONLY);
+    ino_link = fstat(fd_link, &st_link);
+    close(fd_link);
+    if(ino_link < 0)
+      error("fstat_link");
+    if(st_link.type == T_DIR && follow)
+      find(link_buf, depth + 1);
+    else
+       print_file(link_buf, fd, st, depth);
+    break;
+  case T_DIR:
+    //print_file(path, fd, st, depth);
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+      printf(1, "ls: path too long\n");
+      break;
+    }
+    strcpy(buf, path);
+    p = buf + strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+      if(de.inum == 0)
+        continue;
+      memmove(p, de.name, DIRSIZ);
+      p[DIRSIZ] = 0;
+      if(stat(buf, &st) < 0){
+        printf(1, "find: cannot stat %s\n", buf);
+        continue;
+      }
+      
+      //print_file(buf, fd, st, depth);
+
+      
+      // Recursive call
+      if((buf[strlen(buf) - 1] != '.') || ((st.type == 4) && (follow)))
+	find(buf, depth + 1);
+    }
+    break;
+  }
+  close(fd);
+}
+
+void
+print_file(char * buf, int fd, struct stat st, int depth)
+{
+  // By name
+  if(search_by_name && (strcmp(fmtname(buf),name) != 0))
+    return;
+  // Ny size
+  if((search_by_size == 1) && (st.size != size))
+    return;
+  else if((search_by_size == 2) && (st.size <= size))
+    return;
+  else if((search_by_size == 3) && (st.size >= size))
+    return;
+  // By type
+  if((search_by_type == T_DIR) && (st.type != T_DIR))
+    return;
+  else if((search_by_type == T_FILE) && (st.type != T_FILE))
+    return;
+  else if((search_by_type == T_LINK) && (st.type != T_LINK))
+    return;
+  // By tag
+  if(search_by_tag){
+    //memmove(tag_buf, 0,1);
+    if(gettag(fd, tag_key, tag_buf) < 0)
+      return;
+    if((strcmp(tag_buf,tag_val) != 0) && (strcmp("?",tag_val) != 0))
+      return;
+  }
+  
+  if(depth == 0){
+    if((buf[strlen(buf) - 1] == '.') && (buf[strlen(buf) - 2] != '.'))
+      printf(1, "%s \n", ".");
+    else if(buf[strlen(buf) - 2] != '.')
+      printf(1, "%s%s \n", ".", buf);
+  } else {
+    if(buf[strlen(buf) - 1] != '.')
+      printf(1, "%s%s \n", ".", buf);
+  }
+}
+
+void
+print_help()
+{
+  printf(1, "\n  -follow\n");
+  printf(1, "     I don't know lol!\n");
+  printf(1, "  -name <file name>\n");
+  printf(1, "     All files named <file name>\n");
+  printf(1, "  -size <(+/-)n>\n");
+  printf(1, "     All files sized <n> (exactly), <+n> (more than n), <-n> (less than n)\n");
+  printf(1, "  -type <c>\n");
+  printf(1, "     All files of type <c>\n");
+  printf(1, "        d    directory\n");
+  printf(1, "        f    regular file\n");
+  printf(1, "        s    soft link\n");
+  printf(1, "  -tag <key>=<value>\n");
+  printf(1, "     All files tagged by <key>=<value>\n");
+  printf(1, "     Both <key> and <value> must not contain the character '='.\n\n");
+  exit();
+}
+
+char*
+fmtname(char *path)
+{
+  static char buf[DIRSIZ+1];
+  char *p;
+  
+  // Find first character after last slash.
+  for(p = path + strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+  
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+    return p;
+  memmove(buf, p, strlen(p));
+  memset(buf+strlen(p), '\0', DIRSIZ-strlen(p));
+  return buf;
+}
+
+void
+error(char * messege)
+{
+  printf(2, "Error: %s\n", messege);
+  exit();
+}
+
+void
+errori(char * messege, int d)
+{
+  printf(2, "Error: %s %d\n", messege, d);
+  exit();
+}
\ No newline at end of file
Index: file.h
===================================================================
--- file.h	(revision 4)
+++ file.h	(working copy)
@@ -21,7 +21,10 @@
   short minor;
   short nlink;
   uint size;
-  uint addrs[NDIRECT+1];
+  uint addrs[NDIRECT+2];
+  
+  uint tag;           // Tag
+  uint tagnum;        // Number of tags
 };
 #define I_BUSY 0x1
 #define I_VALID 0x2
Index: defs.h
===================================================================
--- defs.h	(revision 4)
+++ defs.h	(working copy)
@@ -50,6 +50,8 @@
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+char*           skipelem(char *path, char *name);
+struct inode*   iget(uint dev, uint inum);
 
 // ide.c
 void            ideinit(void);
@@ -116,6 +118,8 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             symlink(const char *oldpath, const char *newpath);
+int             readlink (const char *pathname, char *buf, uint bufsiz);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
Index: ass4.patch
===================================================================
--- ass4.patch	(revision 0)
+++ ass4.patch	(revision 0)
@@ -0,0 +1,1683 @@
+Index: wc.c
+===================================================================
+--- wc.c	(revision 4)
++++ wc.c	(working copy)
+@@ -35,7 +35,7 @@
+ int
+ main(int argc, char *argv[])
+ {
+-  int fd, i;
++  int fd, i; 
+ 
+   if(argc <= 1){
+     wc(0, "");
+@@ -43,10 +43,8 @@
+   }
+ 
+   for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit();
+-    }
++		if((fd = link_handler(argv[i], 0)) < 0)
++		  exit();
+     wc(fd, argv[i]);
+     close(fd);
+   }
+Index: user.h
+===================================================================
+--- user.h	(revision 4)
++++ user.h	(working copy)
+@@ -23,6 +23,15 @@
+ int sleep(int);
+ int uptime(void);
+ 
++// link
++int symlink(const char *oldpath, const char *newpath);
++int readlink (const char *pathname, char *buf, uint bufsiz);
++
++// tag
++int ftag(int fd, char * key, char * val);
++int funtag(int fd, char * key);
++int gettag(int fd, char * key, char * buf);
++
+ // ulib.c
+ int stat(char*, struct stat*);
+ char* strcpy(char*, char*);
+@@ -36,3 +45,4 @@
+ void* malloc(uint);
+ void free(void*);
+ int atoi(const char*);
++int link_handler(char* path, int omode);
+Index: Makefile
+===================================================================
+--- Makefile	(revision 4)
++++ Makefile	(working copy)
+@@ -151,6 +151,7 @@
+ UPROGS=\
+ 	_cat\
+ 	_echo\
++	_find\
+ 	_forktest\
+ 	_grep\
+ 	_init\
+@@ -164,6 +165,9 @@
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_s1\
++	_slt\
++	_tag\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+@@ -233,6 +237,7 @@
+ EXTRA=\
+ 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+ 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
++	s1.c slt.c tag.c find.c\
+ 	printf.c umalloc.c\
+ 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+ 	.gdbinit.tmpl gdbutil\
+Index: mkfs.c
+===================================================================
+--- mkfs.c	(revision 4)
++++ mkfs.c	(working copy)
+@@ -10,11 +10,15 @@
+ #include "fs.h"
+ #include "stat.h"
+ #include "param.h"
++#include "file.h"
+ 
+-int nblocks = 985;
++# define MAXBUFFSIZE 512
++
++int nblocks = 65456;
+ int nlog = LOGSIZE;
++//int ninodes = 258084;
+ int ninodes = 200;
+-int size = 1024;
++int size = 65536;
+ 
+ int fsfd;
+ struct superblock sb;
+@@ -63,11 +67,14 @@
+   struct dirent de;
+   char buf[512];
+   struct dinode din;
+-
++  
+   if(argc < 2){
+     fprintf(stderr, "Usage: mkfs fs.img files...\n");
+     exit(1);
+   }
++  
++  //printf("\n\n%d\n\n",sizeof(struct inode));
++  //printf("\n\n%s\n\n",argv[1]);
+ 
+   assert((512 % sizeof(struct dinode)) == 0);
+   assert((512 % sizeof(struct dirent)) == 0);
+@@ -89,6 +96,10 @@
+ 
+   printf("used %d (bit %d ninode %zu) free %u log %u total %d\n", usedblocks,
+          bitblocks, ninodes/IPB + 1, freeblock, nlog, nblocks+usedblocks+nlog);
++  
++  
++  //printf("\n\n%d\n\n",size - (usedblocks + nlog));
++  //printf("\n\n%d\n\n",size - (nblocks + usedblocks + nlog));
+ 
+   assert(nblocks + usedblocks + nlog == size);
+ 
+@@ -148,7 +159,6 @@
+   winode(rootino, &din);
+ 
+   balloc(usedblocks);
+-
+   exit(0);
+ }
+ 
+@@ -228,12 +238,13 @@
+ void
+ balloc(int used)
+ {
+-  uchar buf[512];
++  
++  uchar buf[MAXBUFFSIZE];
+   int i;
+ 
+   printf("balloc: first %d blocks have been allocated\n", used);
+-  assert(used < 512*8);
+-  bzero(buf, 512);
++  assert(used < MAXBUFFSIZE * 8);
++  bzero(buf, MAXBUFFSIZE);
+   for(i = 0; i < used; i++){
+     buf[i/8] = buf[i/8] | (0x1 << (i%8));
+   }
+Index: slt.c
+===================================================================
+--- slt.c	(revision 0)
++++ slt.c	(revision 0)
+@@ -0,0 +1,157 @@
++#include "types.h"
++#include "user.h"
++#include "fcntl.h"
++#define BUFSIZ 512
++#define ITOA_BASE 10
++// int test1(){
++//   printf(1, "mkdir dir\n");
++// 	if(mkdir("dir") < 0){
++// 			printf(1, "mkdir failed\n");
++// 			exit();
++// 	}
++// 	
++// 	printf(1, "mkdir dir/dir2\n");
++// 	if(mkdir("dir/dir2") < 0){
++// 			printf(1, "mkdir failed\n");
++// 			exit();
++// 	}
++// 	
++// 	printf(1, "open a file\n");
++// 	fd = open("/dir/dir2/a", O_CREATE | O_RDWR);
++// 	
++// 	printf(1, "write to a file\n");
++// 	if((bytes = write(fd, message, strlen(message))) < 0){
++// 	  printf(1, "write failed\n");
++// 		exit();
++// 	}
++// 	printf(1, "wrote %d bytes\n", bytes);
++// 	
++// 	
++// 	printf(1, "symbolic link dir/b to a\n");
++// 	if(symlink("/dir/dir2/a", "/dir/b") < 0){
++// 	  printf(1, "symbolic link failed\n");
++// 		exit();
++// 	}
++// 	
++// 	printf(1, "symbolic link c to b\n");
++// 	if(symlink("/dir/b", "/c") < 0){
++// 	  printf(1, "symbolic link failed\n");
++// 		exit();
++// 	}		
++// }
++
++// int test2(){
++// 				printf(1, "open a0 file\n");
++// 	fd = open("0", O_CREATE | O_RDWR);
++// 	
++// 	printf(1, "write to 0 file\n");
++// 	if((bytes = write(fd, message, strlen(message))) < 0){
++// 	  printf(1, "write failed\n");
++// 		exit();
++// 	}
++// 	for(i = 1; i < 5; i++){
++// // 		memmove(tmpbuf, but, BUFSIZ);
++// // 		memmove(pbuf, "/dir", 3);
++// // 		pbuf += 3;
++// // 		itoa(i, num);
++// // 		memmove(pbuf, num, strlen(num));
++// // 		pbuf+=strlen(num);
++// 	 
++//     //printf(1, "i: %d\n", i);
++//     itoa(i, num);
++// 		if(mkdir(num) < 0){
++// 			printf(1, "mkdir failed\n");
++// 			exit();
++// 	  }
++// 	  if(chdir(num) < 0){
++// 			printf(1, "chdir failed\n");
++// 			exit();
++// 		}
++// 		itoa(i-1, num2);
++// 		*pbuf = '/'; pbuf++;
++// 		
++// 		memmove(pbuf,num2, strlen(num2));
++// 	  if(symlink(buf, num) < 0){
++// 	    printf(1, "symbolic link failed\n");
++// 		  exit();
++// 	  }	
++// 	  memmove(pbuf, num, strlen(num));
++// 		pbuf+=strlen(num);
++// 	}
++//   
++// 	readlink("4", buf, BUFSIZ);
++// 	// get symlink c's target path
++// 	printf(1, "readpath(\"4\") = %s\n", buf);
++// 	if(close(fd) < 0){
++// 	  printf(1, "close failed\n");
++// 		exit();
++// 	}
++// }
++
++// int test3(){
++// 					mkdir("dir");
++// 	fd = open("dir/test", O_CREATE | O_RDWR);
++// 	if(symlink("dir", "dir2") < 0){
++// 	    printf(1, "symbolic link failed\n");
++// 		  exit();
++// 	}
++// 	readlink("dir2", buf, BUFSIZ);
++// 	printf(1, "target : %s\n", buf);
++// }
++
++char*
++itoa(int xx, char* buff)
++{
++  static char digits[] = "0123456789ABCDEF";
++  char tmp_buf[16];
++  int i, neg, j;
++  uint x;
++
++  neg = 0;
++  if(xx < 0){
++    neg = 1;
++    x = -xx;
++  } else {
++    x = xx;
++  }
++
++  i = 0;
++  do{
++    tmp_buf[i++] = digits[x % ITOA_BASE];
++  }while((x /= ITOA_BASE) != 0);
++  if(neg)
++    tmp_buf[i++] = '-';
++  
++  j = 0;
++  while(--i >= 0)
++    buff[j++] = tmp_buf[i];
++  buff[j] = '\0';
++  return buff;
++}
++
++
++
++
++int main(){
++	//int fd, i;
++	//int bytes;
++	//char *message = "what the fuck\n", num[10],  num2[10];
++	//char buf[BUFSIZ];//, *pbuf = buf;
++// 	memset(buf, '\0', BUFSIZ);
++// 	memset(num, '\0', 10);
++	//int fd;
++	if(symlink("README", "README2") < 0){
++	    printf(1, "symbolic link failed\n");
++		  exit();
++	}
++	if(symlink("x", "x2") < 0){
++	    printf(1, "symbolic link failed\n");
++		  exit();
++	}
++	if(symlink("x2", "x3") < 0){
++	    printf(1, "symbolic link failed\n");
++		  exit();
++	}
++
++	exit();			
++}
+\ No newline at end of file
+Index: fs.c
+===================================================================
+--- fs.c	(revision 4)
++++ fs.c	(working copy)
+@@ -167,7 +167,7 @@
+   initlock(&icache.lock, "icache");
+ }
+ 
+-static struct inode* iget(uint dev, uint inum);
++struct inode* iget(uint dev, uint inum);
+ 
+ //PAGEBREAK!
+ // Allocate a new inode with the given type on device dev.
+@@ -212,6 +212,7 @@
+   dip->nlink = ip->nlink;
+   dip->size = ip->size;
+   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
++  dip->tag = ip->tag;
+   log_write(bp);
+   brelse(bp);
+ }
+@@ -219,7 +220,7 @@
+ // Find the inode with number inum on device dev
+ // and return the in-memory copy. Does not lock
+ // the inode and does not read it from disk.
+-static struct inode*
++struct inode*
+ iget(uint dev, uint inum)
+ {
+   struct inode *ip, *empty;
+@@ -289,6 +290,7 @@
+     ip->nlink = dip->nlink;
+     ip->size = dip->size;
+     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
++    ip->tag = dip->tag;
+     brelse(bp);
+     ip->flags |= I_VALID;
+     if(ip->type == 0)
+@@ -356,9 +358,10 @@
+ static uint
+ bmap(struct inode *ip, uint bn)
+ {
+-  uint addr, *a;
++  uint addr, addr2, *a;
+   struct buf *bp;
+ 
++  // Direct
+   if(bn < NDIRECT){
+     if((addr = ip->addrs[bn]) == 0)
+       ip->addrs[bn] = addr = balloc(ip->dev);
+@@ -366,6 +369,7 @@
+   }
+   bn -= NDIRECT;
+ 
++  // Indirect level 1
+   if(bn < NINDIRECT){
+     // Load indirect block, allocating if necessary.
+     if((addr = ip->addrs[NDIRECT]) == 0)
+@@ -379,6 +383,27 @@
+     brelse(bp);
+     return addr;
+   }
++  bn -= NINDIRECT;
++  
++  // Indirect level 2
++  if(bn < MAXFILE){
++    // Load indirect block, allocating if necessary.
++    if((addr = ip->addrs[NDIRECT + 1]) == 0)
++      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
++    
++    // Load indirect (level 2) block, allocating if necessary.
++    if((addr2 = ((uint*)addr)[bn % NINDIRECT]) == 0)
++      ((uint*)addr)[bn % NINDIRECT] = addr2 = balloc(ip->dev);
++    
++    bp = bread(ip->dev, addr2);
++    a = (uint*)bp->data;
++    if((addr2 = a[bn]) == 0){
++      a[bn] = addr2 = balloc(ip->dev);
++      log_write(bp);
++    }
++    brelse(bp);
++    return addr2;
++  }
+ 
+   panic("bmap: out of range");
+ }
+@@ -392,9 +417,16 @@
+ itrunc(struct inode *ip)
+ {
+   int i, j;
+-  struct buf *bp;
+-  uint *a;
++  struct buf *bp, *bp2;
++  uint *a, *a2;
++  
++  // Tag
++  if(ip->tag){
++    bfree(ip->dev, ip->tag);
++    ip->tag = 0;
++  }
+ 
++  // Direct
+   for(i = 0; i < NDIRECT; i++){
+     if(ip->addrs[i]){
+       bfree(ip->dev, ip->addrs[i]);
+@@ -402,6 +434,7 @@
+     }
+   }
+   
++  // Indirect level 1
+   if(ip->addrs[NDIRECT]){
+     bp = bread(ip->dev, ip->addrs[NDIRECT]);
+     a = (uint*)bp->data;
+@@ -413,6 +446,28 @@
+     bfree(ip->dev, ip->addrs[NDIRECT]);
+     ip->addrs[NDIRECT] = 0;
+   }
++    
++  // Indirect level 2
++  if(ip->addrs[NDIRECT + 1]){
++    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
++    a = (uint*)bp->data;
++    for(i = 0; i < NINDIRECT; i++){
++      if(((uint*) ip->addrs[NDIRECT + 1])[i]){
++	bp2 = bread(ip->dev, ((uint*) ip->addrs[NDIRECT + 1])[i]);
++	a2 = (uint*)bp2->data;
++	for(j = 0; j < NINDIRECT; j++){
++	  if(a2[j])
++	    bfree(ip->dev, a2[j]);
++	}
++	brelse(bp2);
++	bfree(ip->dev, ((uint*) ip->addrs[NDIRECT + 1])[i]);
++	((uint*) ip->addrs[NDIRECT + 1])[i] = 0;
++      }
++    }
++    brelse(bp);
++    bfree(ip->dev, ip->addrs[NDIRECT]);
++    ip->addrs[NDIRECT] = 0;
++  }
+ 
+   ip->size = 0;
+   iupdate(ip);
+@@ -422,11 +477,12 @@
+ void
+ stati(struct inode *ip, struct stat *st)
+ {
+-  st->dev = ip->dev;
+-  st->ino = ip->inum;
+-  st->type = ip->type;
+-  st->nlink = ip->nlink;
+-  st->size = ip->size;
++  st->dev	= ip->dev;
++  st->ino	= ip->inum;
++  st->type	= ip->type;
++  st->nlink	= ip->nlink;
++  st->size	= ip->size;
++  st->tag	= ip->tag;
+ }
+ 
+ //PAGEBREAK!
+@@ -448,7 +504,7 @@
+   if(off + n > ip->size)
+     n = ip->size - off;
+ 
+-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
++  for(tot = 0; tot < n; tot += m, off += m, dst += m){
+     bp = bread(ip->dev, bmap(ip, off/BSIZE));
+     m = min(n - tot, BSIZE - off%BSIZE);
+     memmove(dst, bp->data + off%BSIZE, m);
+@@ -573,7 +629,7 @@
+ //   skipelem("a", name) = "", setting name = "a"
+ //   skipelem("", name) = skipelem("////", name) = 0
+ //
+-static char*
++char*
+ skipelem(char *path, char *name)
+ {
+   char *s;
+@@ -648,3 +704,122 @@
+ {
+   return namex(path, 1, name);
+ }
++
++// ************ //
++// File Tagging
++// ************ //
++
++int
++tag_place(struct inode * ip, struct buf *bp, char * key)
++{
++  int i;
++  
++  for(i = 0; i < ip->tagnum; i++){
++    if(strncmp((char *)bp->data + ((i * 2) * TAGSIZE), key, TAGSIZE) == 0)
++      return i;
++  }
++  
++  if(ip->tagnum < 16){
++    ip->tagnum++;
++    return (ip->tagnum - 1);
++  }
++  
++  return -1;
++}
++void
++tag_write(struct inode * ip, char * key, char * val)
++{
++  int place;
++  struct buf *bp;
++  int c;
++  
++  bp = bread(ip->dev, ip->tag);
++  place = tag_place(ip, bp, key);
++  if(place < 0){
++    cprintf("Error! A file can not have more that 16 tags!\n");
++    cprintf("File wasn't tagged!\n");
++  } else{
++    for(c = 0; c < TAGSIZE; c++){
++      memset(bp->data + (c + (place * 2 * TAGSIZE)), *(key + c), 1);
++      memset(bp->data + ((c + (place * 2 * TAGSIZE)) + TAGSIZE), *(val + c), 1);
++    }
++    //cprintf("bp->data: %s\n", bp->data + (place * 2 * TAGSIZE));
++    //cprintf("bp->data: %s\n", bp->data + (place * 2 * TAGSIZE) + TAGSIZE);
++  }
++  
++  log_write(bp);
++  brelse(bp);
++  iupdate(ip);
++}
++
++void
++tag_alloc(struct inode * ip)
++{
++  begin_trans();
++  ilock(ip);
++  if(ip->tag == 0){
++    ip->tag = balloc(ip->dev);
++    ip->tagnum = 0;
++  }
++  iunlock(ip);
++  commit_trans();
++}
++
++int
++ftag(int fd, char * key, char * val)
++{
++  struct inode * ip;
++  ip = proc->ofile[fd]->ip;
++  
++  tag_alloc(ip);
++  
++  begin_trans();
++  ilock(ip);
++  tag_write(ip, key, val);
++  iunlock(ip);
++  commit_trans();
++  
++  return 0;
++}
++
++int
++funtag(int fd, char * key)
++{
++  struct inode * ip;
++  ip = iget((uint)fd, 1);
++  return ip->tag;
++}
++
++int
++gettag(int fd, char * key, char * buf)
++{
++  char temp[512];
++  struct inode * ip;
++  struct buf *bp;
++  int i, tagnum;
++  
++  ip = proc->ofile[fd]->ip;
++  ilock(ip);
++  begin_trans();
++  bp = bread(ip->dev, ip->tag);
++  //cprintf("ip->tag: %d\n", ip->tag);
++  tagnum = ip->tagnum;
++  memmove(temp, bp->data, BSIZE);
++  brelse(bp);
++  iupdate(ip);
++  commit_trans();
++  
++  iunlock(ip);
++  
++  //cprintf("tagnum: %d\n",tagnum);
++  for(i = 0; i < tagnum; i++){
++    //cprintf("key: %s\n", temp + ((i * 2) * TAGSIZE));
++    //cprintf("val: %s\n", temp + (((i * 2) + 1) * TAGSIZE));
++    if(strncmp(temp + ((i * 2) * TAGSIZE), key, TAGSIZE) == 0){
++      strncpy(buf, temp + ((i * 2 + 1) * TAGSIZE), TAGSIZE);
++      return 0;
++    }
++  }
++  
++  return -1;
++}
+\ No newline at end of file
+Index: tag.c
+===================================================================
+--- tag.c	(revision 0)
++++ tag.c	(revision 0)
+@@ -0,0 +1,173 @@
++#include "types.h"
++#include "user.h"
++#include "fcntl.h"
++#include "stat.h"
++#include "fs.h"
++
++#define TAG 1
++#define UNTAG 2
++#define GETTAG 3
++
++void print_help();
++int find_and_tag(char * path);
++void error(char * messege);
++void errori(char * messege, int d);
++
++char file_name[512];
++char file_tag[TAGSIZE];
++char file_tag_val[TAGSIZE];
++int operation;
++
++int
++main(int argc, char *argv[])
++{  
++  // Check args
++  if(argc < 2){
++    operation = GETTAG;
++    error("type tag -help for help");
++  } else {
++    if(*argv[1] != '-'){
++      error("type tag -help for help");
++    } else if(strcmp(argv[1],"-help") == 0){
++      print_help();
++    } else if((strcmp(argv[1],"-ftag")) == 0 && (argc == 5)){
++      operation = TAG;
++      strcpy(file_name,argv[2]);
++      strcpy(file_tag,argv[3]);
++      strcpy(file_tag_val,argv[4]);
++    } else if((strcmp(argv[1],"-funtag")) == 0 && (argc == 4)){
++      operation = UNTAG;
++      strcpy(file_name,argv[2]);
++      strcpy(file_tag,argv[3]);
++    } else if((strcmp(argv[1],"-gettag")) == 0 && (argc == 4)){
++      operation = GETTAG;
++      strcpy(file_name,argv[2]);
++      strcpy(file_tag,argv[3]);
++    } else {
++      error("type tag -help for help");
++    }
++  }
++  
++  if(find_and_tag(".") < 0)
++    error("could not find and tag");
++  
++  exit();
++}
++
++void
++print_help()
++{
++  printf(1, "  -ftag <file name> <tag name> <tag value>\n");
++  printf(1, "     Tags all files named <file name> with {<tag name>=<tag value>}\n");
++  printf(1, "  -funtag <file name> <tag name>\n");
++  printf(1, "     Untags all files named <file name> from the <tag name>\n");
++  printf(1, "  -gettag <file name> <tag name>\n");
++  printf(1, "     Get the tag value of <tag name> for all files named <file name>\n\n");
++  printf(1, "   * <file name> and <file tag> should be up to 30 characters!\n\n");
++  exit();
++}
++
++char*
++fmtname(char *path)
++{
++  static char buf[DIRSIZ+1];
++  char *p;
++  
++  // Find first character after last slash.
++  for(p=path+strlen(path); p >= path && *p != '/'; p--)
++    ;
++  p++;
++  
++  // Return blank-padded name.
++  if(strlen(p) >= DIRSIZ)
++    return p;
++  memmove(buf, p, strlen(p));
++  memset(buf+strlen(p), '\0', DIRSIZ-strlen(p));
++  return buf;
++}
++
++int
++make_tag(char * path, int fd)
++{
++  if(strcmp(fmtname(path),file_name) == 0){
++    if(operation == TAG){
++      if(ftag(fd, file_tag, file_tag_val) < 0)
++	return -1;
++      printf(1, "Tagged file: %s Tag < %s = %s >\n", path, file_tag, file_tag_val);
++    } else if(operation == UNTAG){
++      int ans = funtag(fd, file_tag);
++      if(ans < 0)
++	return -1;
++      if(ans)
++	printf(1, "Untagged file: %s\n", path);
++    } else if(operation == GETTAG){
++      int nn;
++      if((nn = gettag(fd, file_tag, file_tag_val)) < 0){
++	return -1;
++      }
++      printf(1, "File: %s Tag < %s = %s >\n", path, file_tag, file_tag_val);
++    }
++  }
++  return 0;
++}
++
++int
++find_and_tag(char * path){
++  char buf[512], *p;
++  int fd, ino;
++  struct stat st;
++  struct dirent de;
++
++  fd = open(path, O_RDONLY);
++    
++  ino = fstat(fd, &st);
++  if(ino < 0)
++    error("fstat");
++
++  switch(st.type){
++  case T_FILE:
++    make_tag(path, fd);
++    break;
++  
++  case T_DIR:
++    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
++      printf(1, "ls: path too long\n");
++      break;
++    }
++    strcpy(buf, path);
++    p = buf+strlen(buf);
++    *p++ = '/';
++    while(read(fd, &de, sizeof(de)) == sizeof(de)){
++      if(de.inum == 0)
++        continue;
++      memmove(p, de.name, DIRSIZ);
++      p[DIRSIZ] = 0;
++      if(stat(buf, &st) < 0){
++        printf(1, "tag: cannot stat %s\n", buf);
++        continue;
++      }
++      
++      // Recursive call
++      if(buf[strlen(buf) - 1] != '.'){
++	find_and_tag(buf);
++      }
++    }
++    break;
++  }
++  close(fd);
++  return 0;
++}
++
++void
++error(char * messege)
++{
++  printf(2, "Error: %s\n", messege);
++  exit();
++}
++
++void
++errori(char * messege, int d)
++{
++  printf(2, "Error: %s %d\n", messege, d);
++  exit();
++}
+\ No newline at end of file
+Index: fs.h
+===================================================================
+--- fs.h	(revision 4)
++++ fs.h	(working copy)
+@@ -21,16 +21,23 @@
+ 
+ #define NDIRECT 12
+ #define NINDIRECT (BSIZE / sizeof(uint))
+-#define MAXFILE (NDIRECT + NINDIRECT)
++#define DNINDIRECT NINDIRECT * NINDIRECT
++#define MAXFILE (NDIRECT + (NINDIRECT * (1 + NINDIRECT)))
+ 
++#define TAGSIZE 32
++#define MAXTAGS 16
++
+ // On-disk inode structure
+ struct dinode {
+-  short type;           // File type
+-  short major;          // Major device number (T_DEV only)
+-  short minor;          // Minor device number (T_DEV only)
+-  short nlink;          // Number of links to inode in file system
+-  uint size;            // Size of file (bytes)
+-  uint addrs[NDIRECT+1];   // Data block addresses
++  short type;		// File type
++  short major;		// Major device number (T_DEV only)
++  short minor;		// Minor device number (T_DEV only)
++  short nlink;		// Number of links to inode in file system
++  uint size;		// Size of file (bytes)
++  uint addrs[NDIRECT+2];// Data block addresses
++  uint tag;		// Tag
++  uint tagnum;		// Number of tags
++  uint padding[13];	// padding
+ };
+ 
+ // Inodes per block.
+@@ -53,3 +60,6 @@
+   char name[DIRSIZ];
+ };
+ 
++int ftag(int fd, char * key, char * val);
++int funtag(int fd, char * key);
++int gettag(int fd, char * key, char * buf);
+\ No newline at end of file
+Index: exec.c
+===================================================================
+--- exec.c	(revision 4)
++++ exec.c	(working copy)
+@@ -6,11 +6,15 @@
+ #include "defs.h"
+ #include "x86.h"
+ #include "elf.h"
++#include "stat.h"
++#include "fs.h"
++#include "file.h"
++#define PATHSIZ 512
+ 
+ int
+ exec(char *path, char **argv)
+ {
+-  char *s, *last;
++  char *s, *last, target[PATHSIZ];
+   int i, off;
+   uint argc, sz, sp, ustack[3+MAXARG+1];
+   struct elfhdr elf;
+@@ -22,6 +26,16 @@
+     return -1;
+   ilock(ip);
+   pgdir = 0;
++	
++	if(ip->type == T_LINK){
++	  iunlockput(ip);
++		readlink(path, target, PATHSIZ);
++		if((ip = namei(target)) == 0){
++		  cprintf("exec: broken link!\n");
++			exit();
++		}
++    ilock(ip);				
++	}
+ 
+   // Check ELF header
+   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
+Index: grep.c
+===================================================================
+--- grep.c	(revision 4)
++++ grep.c	(working copy)
+@@ -39,7 +39,7 @@
+ {
+   int fd, i;
+   char *pattern;
+-  
++
+   if(argc <= 1){
+     printf(2, "usage: grep pattern [file ...]\n");
+     exit();
+@@ -52,10 +52,8 @@
+   }
+ 
+   for(i = 2; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "grep: cannot open %s\n", argv[i]);
+-      exit();
+-    }
++    if((fd = link_handler(argv[i], 0)) < 0)
++		  exit();
+     grep(pattern, fd);
+     close(fd);
+   }
+Index: syscall.c
+===================================================================
+--- syscall.c	(revision 4)
++++ syscall.c	(working copy)
+@@ -98,6 +98,11 @@
+ extern int sys_wait(void);
+ extern int sys_write(void);
+ extern int sys_uptime(void);
++extern int sys_symlink(void);
++extern int sys_readlink(void);
++extern int sys_ftag(void);
++extern int sys_funtag(void);
++extern int sys_gettag(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_fork]    sys_fork,
+@@ -121,6 +126,11 @@
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_symlink] sys_symlink,
++[SYS_readlink] sys_readlink,
++[SYS_ftag]    sys_ftag,
++[SYS_funtag]  sys_funtag,
++[SYS_gettag]  sys_gettag,
+ };
+ 
+ void
+Index: syscall.h
+===================================================================
+--- syscall.h	(revision 4)
++++ syscall.h	(working copy)
+@@ -21,3 +21,10 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++
++#define SYS_symlink   22
++#define SYS_readlink 23
++
++#define SYS_ftag   24
++#define SYS_funtag 25
++#define SYS_gettag 26
+\ No newline at end of file
+Index: stat.h
+===================================================================
+--- stat.h	(revision 4)
++++ stat.h	(working copy)
+@@ -1,6 +1,7 @@
+ #define T_DIR  1   // Directory
+ #define T_FILE 2   // File
+ #define T_DEV  3   // Special device
++#define T_LINK 4   // Link
+ 
+ struct stat {
+   short type;  // Type of file
+@@ -8,4 +9,5 @@
+   uint ino;    // Inode number on device
+   short nlink; // Number of links to file
+   uint size;   // Size of file in bytes
++  uint tag;     // Tag
+ };
+Index: usys.S
+===================================================================
+--- usys.S	(revision 4)
++++ usys.S	(working copy)
+@@ -29,3 +29,8 @@
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(symlink)
++SYSCALL(readlink)
++SYSCALL(ftag)
++SYSCALL(funtag)
++SYSCALL(gettag)
+Index: s1.c
+===================================================================
+--- s1.c	(revision 0)
++++ s1.c	(revision 0)
+@@ -0,0 +1,58 @@
++#include "types.h"
++#include "user.h"
++#include "fcntl.h"
++
++#define KB 1024
++#define MB KB * KB
++
++void error();
++
++int
++main(int argc, char *argv[])
++{
++  int fd;
++  char * buff;
++  
++  if(argc < 2) {
++    printf(2, "Error: number of args\n");
++    exit();
++  }
++  
++  // Creating the file
++  printf(1, "Creating a file..\n");
++  fd = open(argv[1],O_CREATE|O_RDWR);
++  if(fd < 0){
++    printf(2, "Error: opening a file\n");
++    exit();
++  }
++  // Init the buffs
++  buff = malloc(MB);
++  memset(buff, 'x', MB);
++  printf(1, "After msmset\n");
++  
++
++  // Writing 6KB
++    if(write(fd, buff, 6 * KB) < 6 * KB)
++      error(fd);
++  printf(1, "Finished writing 6KB (direct)\n");
++    /*
++  // Writing 70KB
++    if(write(fd, buff, 70 * KB) < 70 * KB)
++      error(fd);
++  printf(1, "Finished writing 70KB (single indirect)\n");
++      
++  // Writing 1MB
++    if(write(fd, buff, MB) < MB)
++      error(fd);
++  printf(1, "Finished writing 1MB (double indirect)\n");
++  */
++  close(fd);
++  exit();
++}
++
++void
++error(int fd){
++  printf(2, "Error: write to file\n");
++  close(fd);
++  exit();
++}
+\ No newline at end of file
+Index: sysproc.c
+===================================================================
+--- sysproc.c	(revision 4)
++++ sysproc.c	(working copy)
+@@ -5,6 +5,7 @@
+ #include "memlayout.h"
+ #include "mmu.h"
+ #include "proc.h"
++#include "fs.h"
+ 
+ int
+ sys_fork(void)
+@@ -87,4 +88,4 @@
+   xticks = ticks;
+   release(&tickslock);
+   return xticks;
+-}
++}
+\ No newline at end of file
+Index: mkdir.c
+===================================================================
+--- mkdir.c	(revision 4)
++++ mkdir.c	(working copy)
+@@ -7,10 +7,35 @@
+ {
+   int i;
+ 
++  /*
+   if(argc < 2){
+     printf(2, "Usage: mkdir files...\n");
+     exit();
+   }
++  */
++  
++  if(argc == 1){
++    if(mkdir("x") < 0){
++      printf(2, "mkdir: %s failed to create\n", "x");
++      exit();
++    }
++    
++    if(mkdir("x/a") < 0){
++      printf(2, "mkdir: %s failed to create\n", "x/a");
++      exit();
++    }
++    
++    if(mkdir("x/b") < 0){
++      printf(2, "mkdir: %s failed to create\n", "x/b");
++      exit();
++    }
++    
++    if(mkdir("x/a/c") < 0){
++      printf(2, "mkdir: %s failed to create\n", "x/a/c");
++      exit();
++    }
++  }
++  
+ 
+   for(i = 1; i < argc; i++){
+     if(mkdir(argv[i]) < 0){
+Index: cat.c
+===================================================================
+--- cat.c	(revision 4)
++++ cat.c	(working copy)
+@@ -2,14 +2,16 @@
+ #include "stat.h"
+ #include "user.h"
+ 
+-char buf[512];
++#define BUFSIZ 512 
+ 
++char buf[BUFSIZ];
++
+ void
+ cat(int fd)
+ {
+   int n;
+-
+-  while((n = read(fd, buf, sizeof(buf))) > 0)
++	
++  while((n = read(fd, buf, BUFSIZ)) > 0)
+     write(1, buf, n);
+   if(n < 0){
+     printf(1, "cat: read error\n");
+@@ -21,17 +23,15 @@
+ main(int argc, char *argv[])
+ {
+   int fd, i;
+-
++	
+   if(argc <= 1){
+     cat(0);
+     exit();
+   }
+ 
+   for(i = 1; i < argc; i++){
+-    if((fd = open(argv[i], 0)) < 0){
+-      printf(1, "cat: cannot open %s\n", argv[i]);
+-      exit();
+-    }
++    if((fd = link_handler(argv[i], 0)) < 0)
++		  exit();
+     cat(fd);
+     close(fd);
+   }
+Index: ls.c
+===================================================================
+--- ls.c	(revision 4)
++++ ls.c	(working copy)
+@@ -45,7 +45,6 @@
+   case T_FILE:
+     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+     break;
+-  
+   case T_DIR:
+     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+       printf(1, "ls: path too long\n");
+Index: sysfile.c
+===================================================================
+--- sysfile.c	(revision 4)
++++ sysfile.c	(working copy)
+@@ -13,7 +13,11 @@
+ #include "fs.h"
+ #include "file.h"
+ #include "fcntl.h"
++#define MAX_PATH_SIZE 512
++#define MAX_LINK_LOOP 16
+ 
++#define min(a, b) ((a) < (b) ? (a) : (b))
++
+ // Fetch the nth word-sized system call argument as a file descriptor
+ // and return both the descriptor and the corresponding struct file.
+ static int
+@@ -272,7 +276,7 @@
+     panic("create: dirlink");
+ 
+   iunlockput(dp);
+-
++  
+   return ip;
+ }
+ 
+@@ -423,3 +427,205 @@
+   fd[1] = fd1;
+   return 0;
+ }
++
++// Links
++
++int 
++sys_symlink(void)
++{
++  int oldpath = 0;
++	int newpath = 0;
++	
++	if((argint(0, &oldpath) < 0) || (argint(1, &newpath) < 0))
++	  return -1;
++	return symlink((const char*)oldpath, (const char*)newpath); 
++}
++
++int 
++sys_readlink(void)
++{
++  int pathname = 0;
++	int buf = 0;
++	int bufsiz = 0;
++	
++	if((argint(0, &pathname) < 0) || (argint(1, &buf) < 0) || (argint(2, &bufsiz) < 0))
++	  return -1;
++	return readlink((const char*)pathname, (char*)buf, (uint)bufsiz);
++}
++
++int create_link(char *path, int omode){
++  int fd;
++  struct file *f;
++  struct inode *ip;
++	
++	// create inode
++	begin_trans();
++  ip = create(path, T_LINK, 0, 0);
++  commit_trans();
++  if(ip == 0){
++		cprintf("create_link: create failed\n");
++    return -1;
++	}
++	if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
++    if(f)
++      fileclose(f);
++    iunlockput(ip);
++		cprintf("create_link: filealloc failed\n");
++    return -1;
++  }
++  iunlock(ip);
++
++  f->type = FD_INODE;
++  f->ip = ip;
++  f->off = 0;
++  f->readable = !(omode & O_WRONLY);
++  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
++  return fd;
++}
++
++int symlink(const char *oldpath, const char *newpath){
++  struct file *newfile;
++	int fd, target_len, dest_len;
++	char target_path[MAX_PATH_SIZE];	 // target path
++	char new_path[MAX_PATH_SIZE];
++	
++	// copy pathes because of const
++  target_len = strlen(oldpath);
++	memset(target_path, 0, MAX_PATH_SIZE);
++	memmove(target_path, oldpath, target_len);
++	target_path[target_len] = '\0';
++	//cprintf("oldpath's copy: %s\n", target_path);
++	
++	dest_len = strlen(newpath);
++	memset(new_path, 0, MAX_PATH_SIZE);
++	memmove(new_path, newpath, dest_len);
++	new_path[dest_len] = '\0';
++	
++	// create a new file and assign it a new inode
++	if((fd = create_link(new_path, O_CREATE | O_RDWR)) < 0){
++	  cprintf("error: create new link file");
++		return -1;
++	}
++	
++	// write target path to new file
++	newfile = proc->ofile[fd];
++  if(filewrite(newfile, target_path, target_len) < 0){
++	  cprintf("error: write target path to file");
++		return -1;
++	}
++  return 0;
++}
++
++int readlinkiter(char *pathname, char *buf, uint bufmaxsiz, uint bufsiz, struct inode *ip, int loopsz){
++  char name[DIRSIZ];
++	char target[MAX_PATH_SIZE];
++	struct inode *next;
++	int nbytes;// newbufsiz;
++	
++	if(((pathname = skipelem(pathname, name)) == 0) || (bufsiz == bufmaxsiz)){ 	
++	  return bufsiz;
++	}
++	ilock(ip);
++  if(ip->type != T_DIR){
++    panic("broken link\n");
++  }
++  if((next = dirlookup(ip, name, 0)) == 0)
++    panic("broken link\n");
++  iunlockput(ip); // done with father
++	ip = next;
++	ilock(ip);
++  if(ip->type != T_LINK){
++		iunlock(ip);
++	  nbytes = min(strlen(name), bufmaxsiz-bufsiz);
++		memmove(buf + bufsiz, name, nbytes);
++		if(bufsiz+nbytes < bufmaxsiz){
++		  buf[bufsiz+nbytes] = '/';
++		  nbytes++;
++		}
++	} else {
++		iunlock(ip);
++		if(loopsz == MAX_LINK_LOOP)
++		  panic("readlink: loop");
++	  nbytes = readi(ip, target, 0, MAX_PATH_SIZE);
++		target[nbytes] = '\0';
++		//cprintf("target: %s\n", target);
++		if(*target == '/'){ // absolute path
++      next = iget(ROOTDEV, ROOTINO);
++			bufsiz = 0; // start of path
++		}
++    else
++      next = idup(proc->cwd);
++		nbytes = readlinkiter(target, buf, bufmaxsiz, bufsiz, next, loopsz + 1);
++	}
++	return readlinkiter(pathname, buf, bufmaxsiz - nbytes, bufsiz + nbytes, ip, 0);
++}
++
++int readlink (const char *pathname, char *buf, uint bufsiz)
++{
++  char pathcpy[MAX_PATH_SIZE];
++	int length = strlen(pathname);
++	int sz;
++	struct inode *ip;
++	if(*pathname == '/') // absolute path
++      ip = iget(ROOTDEV, ROOTINO);
++    else
++      ip = idup(proc->cwd);
++	memset(buf, 0, bufsiz);
++	memset(pathcpy, 0, MAX_PATH_SIZE);
++	memmove(pathcpy, pathname, strlen(pathname)); // because of const
++  pathcpy[length] = '\0';
++  
++	sz = readlinkiter(pathcpy, buf, bufsiz-1, 0, ip, 0);
++	if(sz > 0)	
++	  buf[sz] = '\0';
++	return sz;
++}
++
++// Tagging
++int
++sys_ftag(void)
++{
++  int fd;
++  char * key;
++  char * val;
++  
++  if(argint(0, &fd) < 0)
++    return -1;
++  if(argstr(1, &key) < 0)
++    return -1;
++  if(argstr(2, &val) < 0)
++    return -1;
++  
++  return ftag(fd, key, val);
++}
++
++int
++sys_funtag(void)
++{
++  int fd;
++  char * key;
++  
++  if(argint(0, &fd) < 0)
++    return -1;
++  if(argstr(1, &key) < 0)
++    return -1;
++  
++  return funtag(fd, key);
++}
++
++int
++sys_gettag(void)
++{
++  int fd;
++  char * key;
++  char * buf;
++  
++  if(argint(0, &fd) < 0)
++    return -1;
++  if(argstr(1, &key) < 0)
++    return -1;
++  if(argstr(2, &buf) < 0)
++    return -1;
++  
++  return gettag(fd, key, buf);
++}
+Index: find.c
+===================================================================
+--- find.c	(revision 0)
++++ find.c	(revision 0)
+@@ -0,0 +1,247 @@
++#include "types.h"
++#include "user.h"
++#include "fcntl.h"
++#include "stat.h"
++#include "fs.h"
++
++void error(char * messege);
++void errori(char * messege, int d);
++void find(char * path, int depth);
++char * fmtname(char *path);
++void print_file(char * buf, int fd, struct stat st, int depth);
++void print_help();
++
++int follow = 0;
++int search_by_name = 0;
++char name[128];
++int search_by_size = 0;
++int size;
++int search_by_type = 0;
++int search_by_tag = 0;
++char tag_key[32];
++char tag_val[32];
++char tag_buf[32];
++
++char link_buf[512];
++
++
++int
++main(int argc, char *argv[])
++{
++  // Variables
++  int i;
++  char path[512];
++  char * tag;
++  
++  // Set flags
++  if(argc > 1){
++    for(i = 1; i < argc; i++){
++      if(*argv[i] != '-'){
++	strcpy(path,argv[1]);
++      } else if(strcmp(argv[i],"-follow") == 0){
++	follow++;
++      } else if(strcmp(argv[i],"-help") == 0){
++	print_help();
++      } else if(strcmp(argv[i],"-name") == 0){
++	search_by_name++;
++	i++;
++	strcpy(name,argv[i]);
++      } else if(strcmp(argv[i],"-size") == 0){
++	search_by_size++;
++	i++;
++	if(*argv[i] == '+'){
++	  search_by_size++;
++	  size = atoi(argv[i] + 1);
++	} else if(*argv[i] == '-'){
++	  search_by_size++;
++	  search_by_size++;
++	  size = atoi(argv[i] + 1);
++	} else {
++	  size = atoi(argv[i]);
++	}
++      } else if(strcmp(argv[i],"-type") == 0){
++	i++;
++	if(strcmp(argv[i], "d") == 0){
++	  search_by_type = T_DIR;
++	} else if(strcmp(argv[i], "f") == 0){
++	  search_by_type = T_FILE;
++	} else if(strcmp(argv[i], "s") == 0){
++	  search_by_type = T_LINK;
++	} else {
++	 error("unknown file type"); 
++	}
++      } else if(strcmp(argv[i],"-tag") == 0){
++	search_by_tag++;
++	i++;
++	tag = strchr(argv[i], '=');
++	memmove(tag_key,argv[i], tag - argv[i]);
++	strcpy(tag_val,tag + 1);
++      } else {
++	error("unrecognized flag");
++      }
++    }
++  }
++  
++  // The actual search
++  find(path, 0);
++  
++  exit();
++}
++
++void
++find(char * path, int depth){
++  char buf[512];
++  char * p;
++  int fd, ino, link_len, fd_link, ino_link;
++  struct stat st, st_link;
++  struct dirent de;
++  
++  fd = open(path, O_RDONLY);
++  ino = fstat(fd, &st);
++  if(ino < 0)
++    return;
++
++  switch(st.type){
++  case T_FILE:
++    //printf(1, "file: %s\n", path);
++    print_file(path, fd, st, depth);
++    break;
++    
++  case T_LINK:
++    link_len = readlink(path, link_buf, 512);
++    if(link_len < 0)
++      error("read link");
++    link_buf[link_len - 1] = '\0';
++    fd_link = open(link_buf, O_RDONLY);
++    ino_link = fstat(fd_link, &st_link);
++    close(fd_link);
++    if(ino_link < 0)
++      error("fstat_link");
++    if(st_link.type == T_DIR && follow)
++      find(link_buf, depth + 1);
++    else
++       print_file(link_buf, fd, st, depth);
++    break;
++  case T_DIR:
++    //print_file(path, fd, st, depth);
++    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
++      printf(1, "ls: path too long\n");
++      break;
++    }
++    strcpy(buf, path);
++    p = buf + strlen(buf);
++    *p++ = '/';
++    while(read(fd, &de, sizeof(de)) == sizeof(de)){
++      if(de.inum == 0)
++        continue;
++      memmove(p, de.name, DIRSIZ);
++      p[DIRSIZ] = 0;
++      if(stat(buf, &st) < 0){
++        printf(1, "find: cannot stat %s\n", buf);
++        continue;
++      }
++      
++      //print_file(buf, fd, st, depth);
++
++      
++      // Recursive call
++      if((buf[strlen(buf) - 1] != '.') || ((st.type == 4) && (follow)))
++	find(buf, depth + 1);
++    }
++    break;
++  }
++  close(fd);
++}
++
++void
++print_file(char * buf, int fd, struct stat st, int depth)
++{
++  // By name
++  if(search_by_name && (strcmp(fmtname(buf),name) != 0))
++    return;
++  // Ny size
++  if((search_by_size == 1) && (st.size != size))
++    return;
++  else if((search_by_size == 2) && (st.size <= size))
++    return;
++  else if((search_by_size == 3) && (st.size >= size))
++    return;
++  // By type
++  if((search_by_type == T_DIR) && (st.type != T_DIR))
++    return;
++  else if((search_by_type == T_FILE) && (st.type != T_FILE))
++    return;
++  else if((search_by_type == T_LINK) && (st.type != T_LINK))
++    return;
++  // By tag
++  if(search_by_tag){
++    //memmove(tag_buf, 0,1);
++    if(gettag(fd, tag_key, tag_buf) < 0)
++      return;
++    if((strcmp(tag_buf,tag_val) != 0) && (strcmp("?",tag_val) != 0))
++      return;
++  }
++  
++  if(depth == 0){
++    if((buf[strlen(buf) - 1] == '.') && (buf[strlen(buf) - 2] != '.'))
++      printf(1, "%s \n", ".");
++    else if(buf[strlen(buf) - 2] != '.')
++      printf(1, "%s%s \n", ".", buf);
++  } else {
++    if(buf[strlen(buf) - 1] != '.')
++      printf(1, "%s%s \n", ".", buf);
++  }
++}
++
++void
++print_help()
++{
++  printf(1, "\n  -follow\n");
++  printf(1, "     I don't know lol!\n");
++  printf(1, "  -name <file name>\n");
++  printf(1, "     All files named <file name>\n");
++  printf(1, "  -size <(+/-)n>\n");
++  printf(1, "     All files sized <n> (exactly), <+n> (more than n), <-n> (less than n)\n");
++  printf(1, "  -type <c>\n");
++  printf(1, "     All files of type <c>\n");
++  printf(1, "        d    directory\n");
++  printf(1, "        f    regular file\n");
++  printf(1, "        s    soft link\n");
++  printf(1, "  -tag <key>=<value>\n");
++  printf(1, "     All files tagged by <key>=<value>\n");
++  printf(1, "     Both <key> and <value> must not contain the character '='.\n\n");
++  exit();
++}
++
++char*
++fmtname(char *path)
++{
++  static char buf[DIRSIZ+1];
++  char *p;
++  
++  // Find first character after last slash.
++  for(p = path + strlen(path); p >= path && *p != '/'; p--)
++    ;
++  p++;
++  
++  // Return blank-padded name.
++  if(strlen(p) >= DIRSIZ)
++    return p;
++  memmove(buf, p, strlen(p));
++  memset(buf+strlen(p), '\0', DIRSIZ-strlen(p));
++  return buf;
++}
++
++void
++error(char * messege)
++{
++  printf(2, "Error: %s\n", messege);
++  exit();
++}
++
++void
++errori(char * messege, int d)
++{
++  printf(2, "Error: %s %d\n", messege, d);
++  exit();
++}
+\ No newline at end of file
+Index: file.h
+===================================================================
+--- file.h	(revision 4)
++++ file.h	(working copy)
+@@ -21,7 +21,10 @@
+   short minor;
+   short nlink;
+   uint size;
+-  uint addrs[NDIRECT+1];
++  uint addrs[NDIRECT+2];
++  
++  uint tag;           // Tag
++  uint tagnum;        // Number of tags
+ };
+ #define I_BUSY 0x1
+ #define I_VALID 0x2
+Index: defs.h
+===================================================================
+--- defs.h	(revision 4)
++++ defs.h	(working copy)
+@@ -50,6 +50,8 @@
+ int             readi(struct inode*, char*, uint, uint);
+ void            stati(struct inode*, struct stat*);
+ int             writei(struct inode*, char*, uint, uint);
++char*           skipelem(char *path, char *name);
++struct inode*   iget(uint dev, uint inum);
+ 
+ // ide.c
+ void            ideinit(void);
+@@ -116,6 +118,8 @@
+ int             wait(void);
+ void            wakeup(void*);
+ void            yield(void);
++int             symlink(const char *oldpath, const char *newpath);
++int             readlink (const char *pathname, char *buf, uint bufsiz);
+ 
+ // swtch.S
+ void            swtch(struct context**, struct context*);
Index: ulib.c
===================================================================
--- ulib.c	(revision 4)
+++ ulib.c	(working copy)
@@ -3,6 +3,7 @@
 #include "fcntl.h"
 #include "user.h"
 #include "x86.h"
+#define PATHSZ 512
 
 char*
 strcpy(char *s, char *t)
@@ -103,3 +104,34 @@
     *dst++ = *src++;
   return vdst;
 }
+
+// check if file is of T_LINK type
+// if so, return file descriptor of 
+// it's target file
+int 
+link_handler(char* path, int omode){
+	int fd;
+	char target[PATHSZ];
+	struct stat st;
+
+	if(stat(path, &st) < 0){
+	  printf(1, "fstat failed\n");
+		return -1;
+	}
+  if(st.type == T_LINK){
+	  if(readlink(path, target, PATHSZ) < 0){
+		  printf(1, "readlink failed %s\n", path);
+			return -1;
+		}
+		if((fd = open(target, omode)) < 0){
+      printf(1, "cannot open %s\n", target);
+      return -1;
+    }
+    return fd;
+	}
+	if((fd = open(path, omode)) < 0){
+      printf(1, "cannot open %s\n", path);
+      return -1;
+   }
+   return fd;
+}

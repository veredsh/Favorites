/* div.asm  
 *div N numbers: X1/X2/ ... /XN
 *args - one or more
 *special - (/ 6)-> 1/6  , (/ 4 6 7 0 6) -> bad input can't div in 0
 */
 
 DIVV:
 
	PUSH(FP);
	MOV(FP,SP);		/*OPEN NEW FRAME*/
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R2,IMM(1)); /*R2 WILL BE UP UNTIL GET TO R1*/
	MOV(R1,FPARG(1)); /*SAVE THE ARGUMENTS NUMBER TO R1*/
	CMP(R1,IMM(0));
	JUMP_GT(ANOTHER_CHECK_DIVV);
	SHOW("bad input argument for / need to be one or more arguments. R1 is the num of arguments",R1);
	HALT;
 ANOTHER_CHECK_DIVV:
	MOV(R0,IMM(1));  /*IF I HAVE ONLY 1 ARGUMENT I WANT THE ANS TOBE 1 / ARG SO R0<-1*/
	CMP(R1,IMM(1));
	JUMP_GT(MORE_THEN_1_ARGS_DIVV);
	MOV(R3,IMM(1));
	DIV(R3,INDD((FPARG(2)),1));
	JUMP(DIVV_LOOP_END);

 MORE_THEN_1_ARGS_DIVV:
	MOV(R3,INDD((FPARG(2)),1));/*I HAVE MORE THEN 1 ARGUMENT SO THE ANS IS( THE FIRST ARG / REST ARGS) SO R0<-FPARG(2)*/
 DIVV_LOOP:
	CMP(R1,R2);
	JUMP_EQ(DIVV_LOOP_END);	
	CMP(IND(FPARG(2+R2)),T_INTEGER); /*CHECK IF THE ARGUMENT IN R1 PLACE IS INTEGER*/
	JUMP_EQ(CHECK_ARG_IS_NOT_ZERO_DIVV);
	SHOW("The argumen in the R2+1 place is not integer. print FPARG(2+R2)",FPARG(2+R2));
	HALT;
 CHECK_ARG_IS_NOT_ZERO_DIVV:
	CMP(INDD(FPARG(2+R2),1),IMM(0)); /*CHECK IF THE VALUE OF THE ARG IS NOT 0 BECAUSE IS NOT LEGAL TO DIV IN 0*/
	JUMP_NE(ARG_IS_OK_DIVV); /*JUMP IF NOT EQUAL TO 0*/
	SHOW("is not legal to div in zero. print the arg value",INDD(FPARG(2+R2),1));
	HALT;
 ARG_IS_OK_DIVV:	
	SHOW("R3 BEFORE DIV",R3);
	SHOW("DIV BEFORE ",INDD(FPARG(2+R2),1));
	DIV(R3,INDD(FPARG(2+R2),1)); /*DIV FROM ANS  THE VALUE OF THE SOB_INTEGER THAT IN FPARG(X)*/
	SHOW("R3 AFTER DIV",R3);

	INCR(R2);
	JUMP(DIVV_LOOP);
 DIVV_LOOP_END:
	PUSH(R3);
	CALL(MAKE_SOB_INTEGER); /*NOW R0 POINT TO SOB_INTEGER THAT IS VALUE IS THE 	DIV ANS*/
	DROP(1);
	POP(R3);
	POP(R2);
	POP(R1);
	MOV(SP,FP);
	POP(FP);
 RETURN; 